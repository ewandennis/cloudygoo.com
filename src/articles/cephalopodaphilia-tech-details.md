---
title: 'Cephalopodaphilia: Tech Details'
layout: article.njk
tags: visuals
created: 2015-04-29T12:00:00
navImage: cephalopoaphelia-cropped.jpg
---

Procedural generation is the creation of form, colour or movement through direct calculation.  This is in contrast to the more usual route of storing and retrieving pictures, animations or 3D objects pre-generated by humans.

Proceduralism isn't a new concept - lots of contributors have embiggened the space, many in quite unique ways.  Some of the names that come to mind include [Benoit Mandelbrot](http://en.wikipedia.org/wiki/Mandelbrot_set) and [Edward Lorenz](http://en.wikipedia.org/wiki/Lorenz_system) with their iterative fractal systems: the granddaddys of proceduralism.  [Ed Catmull](http://en.wikipedia.org/wiki/Edwin_Catmull), along with colleague Raphael Rom, designed a conveniently malleable curve or 'spline'.  

More recently [Ken Perlin](http://goo.gl/OgMIOy) cornered the market in 'noise': an extremely versatile procedural building block.  Many of the visual effects in movies, games and TV use [Perlin noise](http://en.wikipedia.org/wiki/Perlin_noise) in some form or other.  Concurrently with Perlin but over in the UK, David Braben and Ian Bell built a game called [Elite](http://en.wikipedia.org/wiki/Elite_%28video_game%29) whose universe was procedurally generated.  Elite had 8 galaxies, each containing 256 planets - not bad for the time.

Bringing us up to date, [modern GPUs](http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html) and [graphics](https://renderman.pixar.com/view/DP25849) [tools](http://povray.org/) exhibit procedural generation features.

We don't need all that horsepower just for a few tentacles though ;)

##### Preliminaries
The goal is to reproduce or at least ape some characteristics of something that exists in nature.  To that end, I have tried to tie tentacular reality to these notes by including small observations to help illustrate each design decision.

We are producing _images_ of tentacles - that means any vector algebra presented will be 2-dimensional, unless otherwise stated.

So with the background out of the way, on to the detail.

##### Foundations: The Curve
The backbone of this model is a realistic curve - one that has proportions and curls like real tentacles.

First though we need a way to draw a curve.  A simple solution is to observe the way one might draw a curve on paper:

1. Pick a position
1. Pick a direction
1. Step away from our position in our direction
1. Repeat steps 2 and 3 until happy

<pre><code>p(n+1) = p(n) + (segment_length * direction)</code></pre>

Lets also define a termination condition: a fixed number of line segments **N** for our curves.

Its often easier to perform calculations along a curve with some notion of where on the curve we are.  The usual solution is to define a parameter **t** which represents a position on the curve from 0 to 1:

<pre><code>t = n / (N-1)</code></pre>

##### From Curve To Tendril

There are 2 main tunable parameters in our curve model.  By altering these, one can produce essentially any curvey shape.

**seg_length**, the line segment size, affects overall curve length. Segment size also interacts with rate of change in direction.  Smaller step size produces tighter curves.

**direction** controls the amount of curvature introduced at each step of the curve.

>Observation: tentacles tend to point in a single general direction.

We can achieve this effect by using a single curve direction over the whole curve and adding small offsets or 'perturbations' at each step:

<pre><code>direction = curve_direction + direction_perturbation</code></pre>

>Observation: tentacles have tighter curvature towards the ends.

To reproduce this, we perturb our direction more towards the end of the curve:

<pre><code>direction_perturbation = perturb() * (1-t)</code></pre>

where **perturb()** gives some smoothly changing value thats small in comparison to the whole curve.

The guiding calculation for our curve is then:

<pre><code>p(n+1) = p(n) + (curve_direction * perturb() *(1-t))</code></pre>

Here's an example rendering using the above principle:

<img src="/media/tentaclecurve.png" alt="Tentacle curve" width="50%" />

##### Filling Out The Curve

>Observation: tentacles are thinner towards the ends.

Now we have a 1D curve, we can give it a 2nd dimension: thickness.  Given a starting **thickness\_start** and ending **thickness\_end**, we can choose a thickness at each point on the curve using **t**:

<pre><code>thickness = thickness_start + (thickness_end-thickness_start)*t</code></pre>

This is also known as linear interpolation or 'lerp' so we'll use the proper term:

<pre><code>thickness = lerp(thickness_start, thickness_end, t)</code></pre>

Our curve changes direction along its length so we have to calculate a 'sideways' direction at each point to draw the width of the tentacle accurately at each point.

First, we need the direction of the curve at a given point:

<pre><code>dir = p(n+1) - p(n)</code></pre>

The 3D cross product of our direction and a unit vector **up** along positive z gives us a **sideways** vector:

<pre><code>sideways(n+0.5) = P x up</code></pre>

_Note: strictly speaking dir gives a direction halfway between p(n) and p(n+1)._

We can now draw our tentacle with **thickness** by drawing 'bones' along the curve or drawing either side of the tentacle by connecting the ends of each bone:

<img src="/media/tentaclepointsbonessides.png" alt="Tentacle shape" width="50%" />

##### 8 Tentacles Make A Cephalopod

Our simple **direction** model gives reasonable effects for a single curve.  When we create a whole set of tentacles though, we want them all to share tentacleness but also to retain some individuality.

Considered from another angle, we want a generalised way to calculate curve direction at each point on each tentacle. We can create a function which provides **direction** value for each of our tentacles and whose value changes smoothly over the whole image.

Our direction function will use a set of 'attractor' points spread over the image, each with a defined radius of influence.  The direction at a given position is the accumulated vector towards each point whose influence covers our sample position:

<img src="/media/vectorfieldframe.png" width="50%">

>Observation: tentacles are more flexible towards the ends.

Now we can apply the direction function to our model in a realistic way by scaling its effect up towards the tentacle end:

<pre><code>p(n+1) = p(n) + (attractorFieldDirection(p(n)) * (1-t))</code></pre>

And finally, here's our final model in action:

<img alt="Tentacle Environment" src="/media/tentacleenvironmentdetail-1.png" width="50%" />

##### Movement

What happens if we move our direction function's attractor points around?

![attractor field](/media/cephvectorfield.gif)

What does that movement do to the tentacles?

<script src="/js/Processing.js/processing.min.js"></script>
<canvas data-processing-sources="/media/Ceph6.pde" width="500" height="500"></canvas>

Interesting.